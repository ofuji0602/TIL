今日の間違えた箇所

&演算子は左辺と右辺の論理積(AND)

|演算子は左辺と右辺の論理和を返します。

論理演算子&&(論理積)は左辺の式で結果が決まる場合、右辺の評価は行わず、最後に評価した値を返します。

1 && nil # => nil
nil && 1 # => nil 右辺は評価されない
|| 演算子は
左辺が true の場合、右辺は実行しません。
左辺が false の場合は、右辺は実行します。
&& 演算子は
左辺が true の場合、右辺は実行します。
左辺が false の場合は、右辺は実行しません
Object#eql?メソッドはレシーバと引数の同値性を検証します。

識別子の開始ラベルによってヒアドキュメントの解釈の方法が異なります。

ヒアドキュメントについて
ヒアドキュメントにインデントを加える場合は、<<-識別子
インデントを取り除くためには、Ruby 2.3から追加された<<~識別子
開始ラベル	説明
"識別子"	式展開が有効
識別子	ダブルクオートと同じ結果
'識別子'	式展開できない
`識別子`	コマンド出力
transposeの例

[[1, 3],
 [1, 4],
 [2, 3],
 [2, 4]
].transpose

# 実行結果
# [[1, 1, 2, 2], [3, 4, 3, 4]]

[1, 2].product([3, 4])

# 実行結果
# [[1, 3], [1, 4], [2, 3], [2, 4]]
compact!はselfからnilを破壊的に取り除くメソッドです。
Fileクラスのクラスメソッドではないもの
File.closeFile.homeFile.pwd
Dirクラスのクラスメソッドではないもの
Dir.directory?Dir.chmodDir.chownDir.dirname
Dirクラスのクラスメソッド
Dir.deleteDir.rmdir
Threadクラスのオブジェクトを生成するメソッドとして正しいもの
Thread.new, Thread.start, Thread.fork
==、eql?は同じ
Hashの初期化は{}またはHash.newで行います。
Hash()で空のHashオブジェクトを生成できる

w+
空ファイルになります。
w
ファイルを書き込みモードで開くため
| Array#unshift | selfの先頭へ引数の値を破壊的に追加します(FIFO)。引数が指定されていない場合は何もしません。|
| Array#shift | selfの先頭より1要素を破壊的に取り出します(FIFO)。 |
a+はファイルを読み込みモード + 追記書き込みモードで開きます。
ファイルの読み込みは、ファイルの先頭から行いますが、書き込みは、ファイルの末尾に行います。
aはファイルを追記書き込みモードで開きます。
ファイルの読み込みを行うことはできません。読み込みを行なった場合は、not opened for reading (IOError)が発生します。
メソッド
strip	文字列の先頭と末尾の空白文字(\t\r\n\f\v)を取り除きます。
chomp	末尾から改行コードを取り除きます。
chop	末尾の文字を取り除きます。

(1..10).each_cons(3) {|arr| p arr }

# <実行結果>
# [1, 2, 3]
# [2, 3, 4]
# [3, 4, 5]
# [4, 5, 6]
# [5, 6, 7]
# [6, 7, 8]
# [7, 8, 9]
# [8, 9, 10]
(1..10).each_slice(3) {|arr| p arr }

# <実行結果>
# [1, 2, 3]
# [4, 5, 6]
# [7, 8, 9]
# [10]
